# [Codeforces 1473D](https://codeforces.com/problemset/problem/1473/D)

## 题目大意

给定一个仅包含`+`、`-`符号的字符串，其长度为`n`，代表一种程序语言。该程序运行时会自带一个变量
`x`，其初始值为`0`。字符串中的每一位都代表一个操作，其中`+`代表变量自增`++x`，`-`代表变量自减
`--x`。

现有`m`个查询区间，每个区间`[l, r]`即询问原程序去掉间区间`[l, r]`（从`1`开始编号）后，执行
此程序的过程中，`x`最多有几种不同的取值可能（包含初始值）。

例如`-+--+--+`这段程序，有如下几个询问：
- `[1, 8]`：去掉后的程序为空，`x`只能取`0`
- `[2, 8]`：去掉后的程序为`-`，`x`依次取`0`, `-1`，共两种取值
- `[2, 5]`：去掉后的程序为`---+`，`x`依次取`0`, `-1`, `-2`, `-3`, `-2`，共四种不同的取值
- `[1, 1]`：去掉后的程序为`+--+--+`，`x`依次取`1`, `0`, `-1`, `0`, `-1`, `-2`, `-1`，
   共四种不同的取值
  
## 解题思路

不难发现，对任意一段「程序」而言，按顺序执行后，不同的取值数目即为取值范围的区间长度。

要求一段代码执行后的取值范围也比较容易，只需模拟一遍，跟踪记录一下`x`值及执行过程中出现的最值即可。

但对多个询问，若每次都扫描一遍，时间复杂度为`O(n * m)`，对`n`, `m`均为`10^5`的范围而言，显然
是要超时的。

分析各询问特点发现，每次询问均涉及执行程序的某个前缀加后缀，因此可以考虑预处理所有前缀与所有后缀
的执行结果。

由于初始值也需要考虑在内，所以仍以`1`作为起始下标，设`prefix[i] = (x, min, max)`表示执行到
第`i`个字符时，`x`的值及历史取值范围`[min, max]`，那么有：
```
prefix[0] = {x: 0, min: 0, max: 0);
for i in 1..=n {
   prefix[i].x = prefix[i-1].x + (if code[i] == '+' { 1 } else { -1 });
   prefix[i].min = min(prefix[i-1].min, prefix[i].x);
   prefix[i].max = max(prefix[i-1].max, prefix[i].x);
}
```
同理，后缀也可按类似方式定义，`suffix[i] = {x, min, max}`表示从结尾开始反向执行到位置`i+1`
时，`x`的值及历史取值范围`[min, max]`。注意到由于是反向执行，`+`、`-`的语义要倒过来。

最后，对于每一个询问区间`[l, r]`，易得前级`prefix[l - 1]`为执行到位置`l-1`时的状态。但后缀
由于是反向执行的，因此不能直接用`suffix[r]`。

观察发现，既然`suffix[r].x`代表从末尾反向执行到位置`r+1`时的`x`值，那么也就是说，以`suffix
[r].x`为初始值，正向执行区间`(r, n]`的代码后，得到的`x`值为`0`，因此只需对`suffix[r]`作
整体偏移，使其减去`prefix[l-1].x - suffix[r].x`的值即可。

这样，只需对取出的前级、后缀两个区间取并集，即为整个程序执行过程中的取值区间了。最终答案正是
此区间的长度。

## Rust小技巧

此题中用到的一个Rust中的小技巧为`Iterator::scan`函数。`scan`函数与`fold`函数类似，将由一个初始
值扫过迭代器，并产生一系列中间值。如下所示代码中的`scan`函数即为`Iterator::scan`函数中所需要
传入的函数参数，它的第一个参数为扫描的中间状态参数，这里即之前提到的三元组`(current, min, max)`；
第二个参数即被扫描的对象，这里即第`i`个代码符号。

正向扫描与逆向扫描可以共用同一个扫描函数，逆向扫描后只需再用一次`map`映射将区间反向即可。
```rust
fn scan((current, min, max): &mut (i32, i32, i32), code: char) -> Option<(i32, i32, i32)> {
   match code {
      '+' => *current += 1,
      '-' => *current -= 1,
      _ => unreachable!(),
   }
   *min = (*min).min(*current);
   *max = (*max).max(*current);
   Some((*current, *min, *max))
}

// 初始值手动添加在最前面
let range_left: Vec<_> = std::iter::once((0, 0, 0))
   .chain(code.chars().scan((0, 0, 0), scan))
   .collect();
let mut range_right: Vec<_> = std::iter::once((0, 0, 0))
   .chain(code.chars().rev().scan((0, 0, 0), scan))
    // 逆向扫描得到的区间需要反向
   .map(|(current, min, max)| (-current, -max, -min))
    // scan后的迭代器未实现`DoubleEndedIterator trait`，因此需要在`collect`结束之后再反转。
   .collect();
range_right.reverse();
```